import Dependencies._
import ProjectSettings._

lazy val commonSettings = Seq(
  organization := "$organization$",
  scalaVersion := "2.12.6",
  crossScalaVersions := Seq("2.11.12", "2.12.6"),
  coverageEnabled in Test := true,
  resolvers ++= Dependencies.commonResolvers,
  exportJars := true
) ++ ProjectSettings.common

lazy val projectName = "$normalizedName$"

/* the root project, it is a simple aggregator of other modules */
lazy val root = Project(id = s"\$projectName", base = file("."))
  .settings(commonSettings: _*)
  .settings(mainClass in Compile := (mainClass in Compile in server).value)
  .settings(addCommandAlias("run", s"\${server.id}/run"))
  .aggregate(server, http, core, client)

/* parse configuration and start everything */
lazy val server = Project(id = s"\$projectName-boot", base = file(s"\$projectName-boot"))
  .settings(commonSettings: _*)
  .settings(executableScriptName := "startup")
  .enablePlugins(JavaAppPackaging)
  .dependsOn(core, http)

/* the http layer of project, contains routes, requests, responses and other stuff */
/* remember that this code could be generated by scripts/generate-http-project */
lazy val http = Project(id = s"\$projectName-http", base = file(s"\$projectName-http"))
  .settings(commonSettings: _*)

/* the core application, contains the logic of the application */
lazy val core = Project(id = s"\$projectName-core", base = file(s"\$projectName-core"))
  .settings(commonSettings: _*)
  .settings(libraryDependencies ++= Seq(
    /* put here your dependencies */
    Typesafe.config, Zio.core
  ))

/* the client to use to access to http services */
lazy val client = Project(id = s"\$projectName-client", base = file(s"\$projectName-client"))
  .settings(ProjectSettings.publish)
